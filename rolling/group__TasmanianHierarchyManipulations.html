<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v7.5: Hierarchical multi-Index manipulation algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v7.5
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__TasmanianHierarchyManipulations.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Hierarchical multi-Index manipulation algorithms<div class="ingroups"><a class="el" href="group__TasmanianSG.html">Sparse Grids</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Hierarchical multi-Index manipulation algorithms:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__TasmanianHierarchyManipulations.png" border="0" alt="" usemap="#group____TasmanianHierarchyManipulations"/>
<map name="group____TasmanianHierarchyManipulations" id="group____TasmanianHierarchyManipulations">
<area shape="rect" id="node2" href="group__TasmanianSG.html" title="Sparse Grids" alt="" coords="5,20,109,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:tsgHierarchyManipulator_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsgHierarchyManipulator_8hpp.html">tsgHierarchyManipulator.hpp</a></td></tr>
<tr class="memdesc:tsgHierarchyManipulator_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithms for manipulating multi-indexes defined by hierarchy rules. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceTasGrid_1_1HierarchyManipulations"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1HierarchyManipulations.html">TasGrid::HierarchyManipulations</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1HierarchyManipulations"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of algorithm to manipulate multi-indexes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1HierarchyManipulations_1_1SplitDirections.html">TasGrid::HierarchyManipulations::SplitDirections</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorganize the <b>points</b> into sets of nodes that align in one-dimension, used for directional localp refinement.  <a href="classTasGrid_1_1HierarchyManipulations_1_1SplitDirections.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0bf339f7a2ecde17ad128f948f7e7f5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga0bf339f7a2ecde17ad128f948f7e7f5d">TasGrid::HierarchyManipulations::computeDAGup</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, const BaseRuleLocalPolynomial *rule)</td></tr>
<tr class="memdesc:ga0bf339f7a2ecde17ad128f948f7e7f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache the indexes slot numbers of the parents of the multi-indexes in <b>mset</b>.  <a href="group__TasmanianHierarchyManipulations.html#ga0bf339f7a2ecde17ad128f948f7e7f5d">More...</a><br /></td></tr>
<tr class="separator:ga0bf339f7a2ecde17ad128f948f7e7f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3481ed5998db30d9f84c76827ff122c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga3481ed5998db30d9f84c76827ff122c2">TasGrid::HierarchyManipulations::computeDAGDown</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, const BaseRuleLocalPolynomial *rule)</td></tr>
<tr class="memdesc:ga3481ed5998db30d9f84c76827ff122c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache the indexes slot numbers of the children of the multi-indexes in <b>mset</b>.  <a href="group__TasmanianHierarchyManipulations.html#ga3481ed5998db30d9f84c76827ff122c2">More...</a><br /></td></tr>
<tr class="separator:ga3481ed5998db30d9f84c76827ff122c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd066648aae92d3691fda9922a6b7df8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#gafd066648aae92d3691fda9922a6b7df8">TasGrid::HierarchyManipulations::computeLevels</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, BaseRuleLocalPolynomial const *rule)</td></tr>
<tr class="memdesc:gafd066648aae92d3691fda9922a6b7df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector that is the sum of the one dimensional levels of each multi-index in the set..  <a href="group__TasmanianHierarchyManipulations.html#gafd066648aae92d3691fda9922a6b7df8">More...</a><br /></td></tr>
<tr class="separator:gafd066648aae92d3691fda9922a6b7df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ced8310197acee593672658ee6f066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga52ced8310197acee593672658ee6f066">TasGrid::HierarchyManipulations::completeToLower</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;refined, BaseRuleLocalPolynomial const *rule)</td></tr>
<tr class="memdesc:ga52ced8310197acee593672658ee6f066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete <b>refined</b> so that the union of <b>refined</b> and <b>mset</b> is lower w.r.t. the <b>rule</b>. .  <a href="group__TasmanianHierarchyManipulations.html#ga52ced8310197acee593672658ee6f066">More...</a><br /></td></tr>
<tr class="separator:ga52ced8310197acee593672658ee6f066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a6184c2b426f9716b218a3c04dfbb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga71a6184c2b426f9716b218a3c04dfbb5">TasGrid::HierarchyManipulations::touchAllImmediateRelatives</a> (std::vector&lt; int &gt; &amp;point, <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, BaseRuleLocalPolynomial const *rule, std::function&lt; void(int i)&gt; apply)</td></tr>
<tr class="memdesc:ga71a6184c2b426f9716b218a3c04dfbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will call <b>apply()</b> with the slot index in <b>mset</b> of each parent/child of <b>point</b>..  <a href="group__TasmanianHierarchyManipulations.html#ga71a6184c2b426f9716b218a3c04dfbb5">More...</a><br /></td></tr>
<tr class="separator:ga71a6184c2b426f9716b218a3c04dfbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef8f0fdeff7ea0f05a0768c4d6c5ce2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#gaef8f0fdeff7ea0f05a0768c4d6c5ce2e">TasGrid::HierarchyManipulations::getLevelZeroPoints</a> (size_t num_dimensions, BaseRuleLocalPolynomial const *rule)</td></tr>
<tr class="memdesc:gaef8f0fdeff7ea0f05a0768c4d6c5ce2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tensor set of all points that sit on level zero (i.e., have no parents).  <a href="group__TasmanianHierarchyManipulations.html#gaef8f0fdeff7ea0f05a0768c4d6c5ce2e">More...</a><br /></td></tr>
<tr class="separator:gaef8f0fdeff7ea0f05a0768c4d6c5ce2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50117f916c20f4e5b9f028212d75871d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga50117f916c20f4e5b9f028212d75871d">TasGrid::HierarchyManipulations::getLargestConnected</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;current, <a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;candidates, BaseRuleLocalPolynomial const *rule)</td></tr>
<tr class="memdesc:ga50117f916c20f4e5b9f028212d75871d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the largest subset of <b>candidates</b> such that adding it to <b>current</b> will result in a connected graph.  <a href="group__TasmanianHierarchyManipulations.html#ga50117f916c20f4e5b9f028212d75871d">More...</a><br /></td></tr>
<tr class="separator:ga50117f916c20f4e5b9f028212d75871d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b99f917762d0a819a421af53a8bf49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa8b99f917762d0a819a421af53a8bf49"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#gaa8b99f917762d0a819a421af53a8bf49">TasGrid::HierarchyManipulations::splitByLevels</a> (size_t stride, typename std::vector&lt; T &gt;::const_iterator ibegin, typename std::vector&lt; T &gt;::const_iterator iend, std::vector&lt; int &gt;::const_iterator ilevels)</td></tr>
<tr class="memdesc:gaa8b99f917762d0a819a421af53a8bf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the range between <b>ibegin</b> and <b>iend</b> into strips of <b>stride</b> and orders those by levels according to the level index in <b>ilevels</b>.  <a href="group__TasmanianHierarchyManipulations.html#gaa8b99f917762d0a819a421af53a8bf49">More...</a><br /></td></tr>
<tr class="separator:gaa8b99f917762d0a819a421af53a8bf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e71f808c63d1ec5487f9f8fc3ec1d85"><td class="memItemLeft" align="right" valign="top"><a id="ga5e71f808c63d1ec5487f9f8fc3ec1d85"></a>
std::vector&lt; <a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga5e71f808c63d1ec5487f9f8fc3ec1d85">TasGrid::HierarchyManipulations::splitByLevels</a> (<a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;mset, std::vector&lt; int &gt; const &amp;levels)</td></tr>
<tr class="memdesc:ga5e71f808c63d1ec5487f9f8fc3ec1d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that operates on an entire multi-index set. <br /></td></tr>
<tr class="separator:ga5e71f808c63d1ec5487f9f8fc3ec1d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7bf2cc030e5bc451248ce56080a455a"><td class="memTemplParams" colspan="2"><a id="gab7bf2cc030e5bc451248ce56080a455a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab7bf2cc030e5bc451248ce56080a455a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#gab7bf2cc030e5bc451248ce56080a455a">TasGrid::HierarchyManipulations::splitByLevels</a> (<a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; T &gt; const &amp;data, std::vector&lt; int &gt; const &amp;levels)</td></tr>
<tr class="memdesc:gab7bf2cc030e5bc451248ce56080a455a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that operates on an entire <a class="el" href="classTasGrid_1_1Data2D.html" title="Generic 2D data structure divided into contiguous strips of fixed length (similar to a matrix)...">Data2D</a> structure set. <br /></td></tr>
<tr class="separator:gab7bf2cc030e5bc451248ce56080a455a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6594bfaf4f5a85503ce295f9b92c8160"><td class="memItemLeft" align="right" valign="top"><a id="ga6594bfaf4f5a85503ce295f9b92c8160"></a>
std::vector&lt; <a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianHierarchyManipulations.html#ga6594bfaf4f5a85503ce295f9b92c8160">TasGrid::HierarchyManipulations::splitByLevels</a> (<a class="el" href="classTasGrid_1_1StorageSet.html">StorageSet</a> const &amp;stortage, std::vector&lt; int &gt; const &amp;levels)</td></tr>
<tr class="memdesc:ga6594bfaf4f5a85503ce295f9b92c8160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that operates on an entire <a class="el" href="classTasGrid_1_1StorageSet.html" title="Class that stores values, i.e., model outputs, the order of the values is in sync with the order of s...">StorageSet</a> structure set. <br /></td></tr>
<tr class="separator:ga6594bfaf4f5a85503ce295f9b92c8160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>One Dimensional Hierarchy</dt><dd>The construction of Global, Sequence and Fourier grids the multi-index hierarchy is associated with tensors and has very simple structure, in one dimension there is only one parent and one child indicated by the previous and next index. The Local-Polynomial and Wavelet girds use more complex hierarchies that have multiple children and (in some cases) parents. Many of the associated manipulation algorithms require a <b>rule</b> object that describes the hierarchy, and additional algorithms are needed to handle the more complex parent-child relations.</dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0bf339f7a2ecde17ad128f948f7e7f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf339f7a2ecde17ad128f948f7e7f5d">&#9670;&nbsp;</a></span>computeDAGup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt;int&gt; TasGrid::HierarchyManipulations::computeDAGup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BaseRuleLocalPolynomial *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache the indexes slot numbers of the parents of the multi-indexes in <b>mset</b>. </p>
<p>Each node defined by a multi-index in <b>mset</b> can have one or more parents in each direction, where the parent-offspring relation is defined by the <b>rule</b>. For each index in <b>mset</b>, the <a class="el" href="classTasGrid_1_1Data2D.html" title="Generic 2D data structure divided into contiguous strips of fixed length (similar to a matrix)...">Data2D</a> structure <b>parents</b> will hold a strip with the location of each parent in <b>mset</b> (or -1 if the parent is missing from <b>mset</b>). </p>

</div>
</div>
<a id="ga3481ed5998db30d9f84c76827ff122c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3481ed5998db30d9f84c76827ff122c2">&#9670;&nbsp;</a></span>computeDAGDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt;int&gt; TasGrid::HierarchyManipulations::computeDAGDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BaseRuleLocalPolynomial *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache the indexes slot numbers of the children of the multi-indexes in <b>mset</b>. </p>
<p>Each node defined by a multi-index in <b>mset</b> can have one or more children in each direction, where the parent-offspring relation is defined by the <b>rule</b>. For each index in <b>mset</b>, the returned <a class="el" href="classTasGrid_1_1Data2D.html" title="Generic 2D data structure divided into contiguous strips of fixed length (similar to a matrix)...">Data2D</a> structure will hold a strip with the location of each child in <b>mset</b> (or -1 if the kid is missing from <b>mset</b>). </p>

</div>
</div>
<a id="gafd066648aae92d3691fda9922a6b7df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd066648aae92d3691fda9922a6b7df8">&#9670;&nbsp;</a></span>computeLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; TasGrid::HierarchyManipulations::computeLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseRuleLocalPolynomial const *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector that is the sum of the one dimensional levels of each multi-index in the set.. </p>

</div>
</div>
<a id="ga52ced8310197acee593672658ee6f066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52ced8310197acee593672658ee6f066">&#9670;&nbsp;</a></span>completeToLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::HierarchyManipulations::completeToLower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseRuleLocalPolynomial const *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete <b>refined</b> so that the union of <b>refined</b> and <b>mset</b> is lower w.r.t. the <b>rule</b>. . </p>

</div>
</div>
<a id="ga71a6184c2b426f9716b218a3c04dfbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71a6184c2b426f9716b218a3c04dfbb5">&#9670;&nbsp;</a></span>touchAllImmediateRelatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::HierarchyManipulations::touchAllImmediateRelatives </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>mset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseRuleLocalPolynomial const *&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int i)&gt;&#160;</td>
          <td class="paramname"><em>apply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will call <b>apply()</b> with the slot index in <b>mset</b> of each parent/child of <b>point</b>.. </p>

</div>
</div>
<a id="gaef8f0fdeff7ea0f05a0768c4d6c5ce2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef8f0fdeff7ea0f05a0768c4d6c5ce2e">&#9670;&nbsp;</a></span>getLevelZeroPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::HierarchyManipulations::getLevelZeroPoints </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseRuleLocalPolynomial const *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tensor set of all points that sit on level zero (i.e., have no parents). </p>

</div>
</div>
<a id="ga50117f916c20f4e5b9f028212d75871d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50117f916c20f4e5b9f028212d75871d">&#9670;&nbsp;</a></span>getLargestConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> TasGrid::HierarchyManipulations::getLargestConnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1MultiIndexSet.html">MultiIndexSet</a> const &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseRuleLocalPolynomial const *&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the largest subset of <b>candidates</b> such that adding it to <b>current</b> will result in a connected graph. </p>

</div>
</div>
<a id="gaa8b99f917762d0a819a421af53a8bf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b99f917762d0a819a421af53a8bf49">&#9670;&nbsp;</a></span>splitByLevels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTasGrid_1_1Data2D.html">Data2D</a>&lt;T&gt; &gt; TasGrid::HierarchyManipulations::splitByLevels </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; T &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>ibegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; T &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>iend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>ilevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the range between <b>ibegin</b> and <b>iend</b> into strips of <b>stride</b> and orders those by levels according to the level index in <b>ilevels</b>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
